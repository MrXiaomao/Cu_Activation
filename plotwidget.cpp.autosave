#include "plotwidget.h"
#include "qcustomplot.h"
#include <QGridLayout>
#include <QtMath>

PlotWidget::PlotWidget(QWidget *parent) : QWidget(parent)
    , titleTextTtem(nullptr)
    , coordsTextItem(nullptr)
    , textTipItem(nullptr)
    , lineFlagItem(nullptr)
{
    this->setContentsMargins(0, 0, 0, 0);
    this->setLayout(new QGridLayout(this));
    this->layout()->setMargin(0);
    initCustomPlot();
}

void PlotWidget::setName(QString name)
{
    this->title = name;
    if (titleTextTtem)
        titleTextTtem->setText(name);
}

void PlotWidget::initCustomPlot()
{
    customPlot = new QCustomPlot(this);
    customPlot->setObjectName(QString("customPlot_%1").arg(title));
    customPlot->setLocale(QLocale(QLocale::Chinese, QLocale::China));
    customPlot->installEventFilter(this);
    this->layout()->addWidget(customPlot);

    // 设置选择容忍度，即鼠标点击点到数据点的距离
    //customPlot->setSelectionTolerance(5);
    // 设置全局抗锯齿
    //customPlot->setAntialiasedElements(QCP::aeAll);
    customPlot->setNotAntialiasedElements(QCP::aeAll);
    // 图例名称隐藏
    customPlot->legend->setVisible(false);
    // 图例名称显示位置
    customPlot->axisRect()->insetLayout()->setInsetAlignment(0, Qt::AlignTop|Qt::AlignRight);
    // 设置边界
    customPlot->setContentsMargins(0, 0, 0, 0);
    // 背景色
    customPlot->setBackground(QBrush(QColor(0, 0, 127)));
    // 图像画布边界
    customPlot->axisRect()->setMinimumMargins(QMargins(0, 0, 0, 0));
    // 坐标背景色
    customPlot->axisRect()->setBackground(QColor(0, 0, 255));
    // 允许拖拽，缩放
    customPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);
    // 允许轴自适应大小
    //customPlot->graph(0)->rescaleValueAxis(true);
    customPlot->xAxis->rescale(false);
    customPlot->yAxis->rescale(true);
    // 设置刻度范围
    QSharedPointer<QCPAxisTickerFixed> axisTickerFixed(new QCPAxisTickerFixed);
    axisTickerFixed->setTickStep(256);
    axisTickerFixed->setScaleStrategy(QCPAxisTickerFixed::ssNone);
    customPlot->xAxis->setTicker(axisTickerFixed);
    customPlot->xAxis->setRange(0, 2048);
    customPlot->yAxis->setRange(0, 10000);
    customPlot->yAxis->ticker()->setTickCount(5);
    customPlot->xAxis->ticker()->setTickCount(8);
    // 设置刻度可见
    customPlot->xAxis->setTicks(false);
    customPlot->xAxis2->setTicks(false);
    customPlot->yAxis->setTicks(false);
    customPlot->yAxis2->setTicks(false);
    // 设置轴线可见
    customPlot->xAxis->setVisible(false);
    customPlot->xAxis2->setVisible(false);
    customPlot->yAxis->setVisible(false);
    customPlot->yAxis2->setVisible(false);
    //customPlot->axisRect()->setupFullAxesBox();//四边安装轴并显示
    // 设置刻度标签可见
    customPlot->xAxis->setTickLabels(false);
    customPlot->xAxis2->setTickLabels(false);
    customPlot->yAxis->setTickLabels(false);
    customPlot->yAxis2->setTickLabels(false);
    // 设置子刻度可见
    customPlot->xAxis->setSubTicks(false);
    customPlot->xAxis2->setSubTicks(false);
    customPlot->yAxis->setSubTicks(false);
    customPlot->yAxis2->setSubTicks(false);
    //设置轴标签名称
    //customPlot->xAxis->setLabel(QObject::tr("计数"));
    //customPlot->yAxis->setLabel(QObject::tr("能量/Kev"));
    // 设置网格线颜色
    customPlot->xAxis->grid()->setPen(QPen(QColor(180, 180, 180, 128), 1, Qt::PenStyle::DashLine));
    customPlot->yAxis->grid()->setPen(QPen(QColor(180, 180, 180, 128), 1, Qt::PenStyle::DashLine));
    customPlot->xAxis->grid()->setSubGridPen(QPen(QColor(50, 50, 50, 128), 1, Qt::DotLine));
    customPlot->yAxis->grid()->setSubGridPen(QPen(QColor(50, 50, 50, 128), 1, Qt::DotLine));
    customPlot->xAxis->grid()->setZeroLinePen(QPen(QColor(50, 50, 50, 100), 1, Qt::SolidLine));
    customPlot->yAxis->grid()->setZeroLinePen(QPen(QColor(50, 50, 50, 100), 1, Qt::SolidLine));
    // 设置网格线是否可见
    customPlot->xAxis->grid()->setVisible(false);
    customPlot->yAxis->grid()->setVisible(false);
    // 设置子网格线是否可见
    customPlot->xAxis->grid()->setSubGridVisible(false);
    customPlot->yAxis->grid()->setSubGridVisible(false);

    // 添加散点图
    QCPGraph * curGraph = customPlot->addGraph(customPlot->xAxis, customPlot->yAxis);
    curGraph->setAntialiased(false);
    Q_UNUSED(curGraph);
    customPlot->graph(0)->setPen(QPen(Qt::white));
    customPlot->graph(0)->selectionDecorator()->setPen(QPen(Qt::white));
    //customPlot->graph(0)->setLineStyle(QCPGraph::lsLine);
    customPlot->graph(0)->setLineStyle(QCPGraph::lsNone);// 隐藏线性图
    customPlot->graph(0)->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssPlus, 2));//显示散点图

    //随机数据
    static int lastV = qrand() % 100 + 5000;
    QVector<double> keys, values;
    for (int i=0; i<2048; i++){
        keys << i;

        lastV += qrand() % 100 - 50;
        values << lastV;
    }
    customPlot->graph(0)->setData(keys, values);

    QCPGraph * shadowGraph = customPlot->addGraph(customPlot->xAxis, customPlot->yAxis);
    shadowGraph->setAntialiased(false);
    Q_UNUSED(shadowGraph);
    customPlot->graph(1)->setPen(QColor(255,0,255,255));
    customPlot->graph(1)->selectionDecorator()->setPen(QColor(255,0,255,255));
    //customPlot->graph(1)->setLineStyle(QCPGraph::lsLine);
    customPlot->graph(1)->setLineStyle(QCPGraph::lsNone);// 隐藏线性图
    customPlot->graph(1)->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssPlus, 2));//显示散点图

    // 文本元素随窗口变动而变动
    titleTextTtem = new QCPItemText(customPlot);
    titleTextTtem->setColor(Qt::white);
    titleTextTtem->position->setType(QCPItemPosition::ptAbsolute);
    titleTextTtem->setPositionAlignment(Qt::AlignTop | Qt::AlignLeft);
    titleTextTtem->setTextAlignment(Qt::AlignLeft);
    titleTextTtem->setFont(QFont(font().family(), 12));
    titleTextTtem->setPadding(QMargins(8, 0, 0, 0));
    titleTextTtem->position->setCoords(10.0, 10.0);//窗口坐标值
    titleTextTtem->setText(QString("%1").arg(title));

    // 文本元素随坐标变动而变动
    coordsTextItem = new QCPItemText(customPlot);
    coordsTextItem->setColor(QColor(0,128,128,255));// 字体色
    coordsTextItem->setPen(QColor(130,130,130,255));// 边框
    coordsTextItem->setBrush(QBrush(QColor(255,255,225,255)));// 背景色
    coordsTextItem->setPositionAlignment(Qt::AlignBottom | Qt::AlignLeft);
    coordsTextItem->position->setType(QCPItemPosition::ptPlotCoords);
    coordsTextItem->setTextAlignment(Qt::AlignLeft);
    coordsTextItem->setFont(QFont(font().family(), 12));
    coordsTextItem->setPadding(QMargins(5, 5, 5, 5));
    coordsTextItem->position->setCoords(250.0, 1000.0);//X、Y轴坐标值
    coordsTextItem->setText("峰: 239.10 = 207.37 keV\n"
                            "半高宽: 40.15 FW[1/5]M:71.59\n"
                            "库: Sn-113[Tin]在255.04; 0 Bq\n"
                            "总计数面积: 623036\n"
                            "净面积: 57994 +/-3703\n"
                            "总计数/净计数 比率:731.18/68.06 cps");
    coordsTextItem->setVisible(false);

    textTipItem = new QCPItemText(customPlot);
    textTipItem->setPositionAlignment(Qt::AlignBottom|Qt::AlignLeft);
    textTipItem->position->setType(QCPItemPosition::ptAbsolute);
    textTipItem->setFont(QFont(font().family(), 15));
    textTipItem->setPen(QPen(Qt::black));
    textTipItem->setBrush(Qt::white);
    textTipItem->setVisible(false);

    lineFlagItem = new QCPItemLine(customPlot);
    lineFlagItem->setAntialiased(false);
    lineFlagItem->start->setType(QCPItemPosition::ptPlotCoords);//QCPItemPosition::ptAbsolute);
    lineFlagItem->end->setType(QCPItemPosition::ptPlotCoords);//QCPItemPosition::ptAbsolute);
    lineFlagItem->setPen(QPen(QColor(255,0,255,255), 3, Qt::SolidLine));
    lineFlagItem->setSelectedPen(QPen(QColor(255,0,255,255), 3, Qt::SolidLine));
    lineFlagItem->setVisible(false);

    dragRectItem = new QCPItemRect(customPlot);
    dragRectItem->setAntialiased(false);
    dragRectItem->topLeft->setType(QCPItemPosition::ptPlotCoords);//QCPItemPosition::ptAbsolute);
    dragRectItem->bottomRight->setType(QCPItemPosition::ptPlotCoords);//QCPItemPosition::ptAbsolute);
    dragRectItem->setPen(QPen(QColor(255,255,225,255), 2, Qt::SolidLine));// 边框
    dragRectItem->setBrush(Qt::NoBrush);// 背景色
    dragRectItem->setSelectedPen(QPen(QColor(255,255,225,255), 3, Qt::SolidLine));
    dragRectItem->setVisible(false);

    // 图形刷新
    customPlot->replot();

//    QTimer *timerUpdate = new QTimer(this);
//    static int timerRef = 0;
//    static int lastV = qrand() % 100 + 5000;
//    connect(timerUpdate, &QTimer::timeout, this, [=](){
//        // 更新数据
//        lastV += qrand() % 100 - 50;
//        customPlot->graph(0)->addData(timerRef++, lastV);

//        // 保持图形范围合理
//        if (timerRef >= 2048)
//            customPlot->xAxis->setRange(timerRef - 2048, 2048, Qt::AlignLeft);

//        // 重新绘制
//        customPlot->replot();

//        customPlot->yAxis->rescale(true);
//    });
//    timerUpdate->start(10);

    connect(customPlot, SIGNAL(plottableClick(QCPAbstractPlottable*, int, QMouseEvent*)), this, SLOT(slotPlotClick(QCPAbstractPlottable*, int, QMouseEvent*)));
    //connect(customPlot, SIGNAL(selectionChangedByUser()), this, SLOT(slotSelectionChanged()));
    connect(customPlot, SIGNAL(beforeReplot()), this, SLOT(slotBeforeReplot()));
}

QCustomPlot *PlotWidget::customPlotInstance() const
{
    return this->customPlot;
}

#include <QMouseEvent>
bool PlotWidget::eventFilter(QObject *watched, QEvent *event)
{
    if (watched != this){
        if (event->type() == QEvent::MouseButtonPress){
            QMouseEvent *e = reinterpret_cast<QMouseEvent*>(event);
            if (watched->inherits("QCustomPlot")){
                //QCustomPlot* customPlot = qobject_cast<QCustomPlot*>(watched);
                if (e->button() == Qt::LeftButton) {
                    if (e->modifiers() & Qt::ControlModifier){
                        customPlot->setInteraction(QCP::iRangeDrag, false);
                    }

                    isPressed = true;
                    dragStart = e->pos();
                    customPlot->replot();
                } else if (e->button() == Qt::RightButton) {
                    isPressed = false;
                    isDragging = false;
                    customPlot->graph(1)->setData(QVector<double>(), QVector<double>());//.reset();// ->data().data()->clear();
                    dragRectItem->setVisible(false);
                    coordsTextItem->setVisible(false);
                    lineFlagItem->setVisible(false);
                    customPlot->xAxis->setRange(0, 2048);
                    customPlot->yAxis->setRange(0, 10000);
                    customPlot->replot();

                    setCursor(Qt::ArrowCursor);
                }
            }
        } else if (event->type() == QEvent::MouseMove){
            QMouseEvent *e = reinterpret_cast<QMouseEvent*>(event);
            if (watched->inherits("QCustomPlot")){
                //QCustomPlot* customPlot = qobject_cast<QCustomPlot*>(watched);
                if (isPressed){
                    if (!isDragging) {
                        if (e->modifiers() & Qt::ControlModifier){
                            QCPGraph *graph = customPlot->graph(0);

                            dragRectItem->setProperty("top", dragStart.y());
                            dragRectItem->setProperty("left", dragStart.x());

                            double key, value;
                            graph->pixelsToCoords(dragStart.x(), dragStart.y(), key, value);
                            dragRectItem->topLeft->setCoords(key, value);

                            coordsTextItem->setVisible(false);
                            dragRectItem->setVisible(false);
                            customPlot->replot();

                            setCursor(Qt::CrossCursor);
                        } else {
                            setCursor(Qt::SizeAllCursor);
                        }

                        isDragging = true;
                    }else {
                        if (e->modifiers() & Qt::ControlModifier){
                            QCPGraph *graph = customPlot->graph(0);
                            dragRectItem->setProperty("bottom", e->pos().y());
                            dragRectItem->setProperty("right", e->pos().x());

                            double key, value;
                            graph->pixelsToCoords(e->pos().x(), e->pos().y(), key, value);
                            dragRectItem->bottomRight->setCoords(key, value);
                            dragRectItem->setVisible(true);

                            //颜色更新
                            double key_from = dragRectItem->topLeft->key();
                            double key_to = dragRectItem->bottomRight->key();
                            double key_temp = key_from;
                            key_from = qMin(key_from, key_to);
                            key_to = qMax(key_temp, key_to);

                            QMap<qint32, double> mapKeyValues;
                            graph = customPlot->graph(1);
                            for (int i=0; i<graph->data()->size(); ++i){
                                mapKeyValues[graph->data()->at(i)->key] = graph->data()->at(i)->value;
                            }

                            graph = customPlot->graph(0);
                            for (int i=0; i<graph->data()->size(); ++i){
                                if (graph->data()->at(i)->key>=key_from && graph->data()->at(i)->key<=key_to) {
                                    mapKeyValues[graph->data()->at(i)->key] = graph->data()->at(i)->value;
                                }
                            }

                            // 这里需要对数据去重和排序处理
                            QVector<double> keys, values;
                            for (QMap<qint32, double>::iterator iter = mapKeyValues.begin(); iter != mapKeyValues.end(); ++iter){
                                keys << (double)iter.key();
                                values << (double)iter.value();
                            }
                            customPlot->graph(1)->setData(keys, values);
                            customPlot->replot();
                        }
                    }
                }
            }
        } else if (event->type() == QEvent::MouseButtonRelease){
            QMouseEvent *e = reinterpret_cast<QMouseEvent*>(event);
            if (watched->inherits("QCustomPlot")){
                //QCustomPlot* customPlot = qobject_cast<QCustomPlot*>(watched);
                if (e->button() == Qt::LeftButton) {
                    setCursor(Qt::ArrowCursor);

                    if (e->modifiers() & Qt::ControlModifier){
                        if (dragRectItem->visible()){
                            QCPGraph *graph = customPlot->graph(0);
                            coordsTextItem->setText("峰: 239.10 = 207.37 keV\n"
                                                    "半高宽: 40.15 FW[1/5]M:71.59\n"
                                                    "库: Sn-113[Tin]在255.04; 0 Bq\n"
                                                    "总计数面积: 623036\n"
                                                    "净面积: 57994 +/-3703\n"
                                                    "总计数/净计数 比率:731.18/68.06 cps");
                            double key, value;
                            graph->pixelsToCoords(e->pos().x(), e->pos().y(), key, value);
                            coordsTextItem->position->setCoords(key, value);
                            coordsTextItem->setVisible(true);
                            customPlot->replot();
                        }
                    }

                    isPressed = false;
                    isDragging = false;

                    customPlot->setInteraction(QCP::iRangeDrag, true);
                }
            }
        } else if (event->type() == QEvent::MouseButtonDblClick){
            emit sigMouseDoubleClickEvent();
        }
    }

    return QWidget::eventFilter(watched, event);
}

#include <QTimer>
void PlotWidget::slotPlotClick(QCPAbstractPlottable *plottable, int dataIndex, QMouseEvent *event)
{
    QCPGraph* graphFirst = customPlot->graph(0);
    if (plottable != graphFirst){
        
    }
    QCPGraph *graph = customPlot->graph(0);
    QSharedPointer<QCPGraphDataContainer> data = graph->data();
    const QCPGraphData *ghd = data->at(dataIndex);

    //显示轴信息
    QString text = QString::number(ghd->key,10,0) + "," + QString::number(ghd->value,10,0);
    textTipItem->setText(text);
    textTipItem->position->setCoords(event->pos().x() + 3, event->pos().y() - 3);
    textTipItem->setVisible(true);

    //显示标记点
    //lineFlagItem->start->setCoords(ghd->key, ghd->value);
    lineFlagItem->setProperty("key", ghd->key);
    lineFlagItem->setProperty("value", ghd->value);
//    double key, value;
//    graph->pixelsToCoords(event->pos().x() + 1, event->pos().y() - 2, key, value);
//    lineFlagItem->start->setCoords(key, value);
//    graph->pixelsToCoords(event->pos().x() + 1, event->pos().y() - 32, key, value);
//    lineFlagItem->end->setCoords(key, value);
    lineFlagItem->setVisible(true);

    customPlot->replot();

    setCursor(Qt::ArrowCursor);
    QTimer::singleShot(1000, this, [=](){
       textTipItem->setVisible(false);
       customPlot->replot();
    });
}

void PlotWidget::slotBeforeReplot()
{
    if (lineFlagItem->visible()){
        QCPGraph *graph = customPlot->graph(0);
        double key = lineFlagItem->property("key").toUInt();
        double value = lineFlagItem->property("value").toUInt();
        QPointF pixels = graph->coordsToPixels(key, value);
        graph->pixelsToCoords(pixels.x() + 1, pixels.y() - 2, key, value);
        lineFlagItem->start->setCoords(key, value);
        graph->pixelsToCoords(pixels.x() + 1, pixels.y() - 32, key, value);
        lineFlagItem->end->setCoords(key, value);
    }
}

void PlotWidget::slotSelectionChanged() {
    QList<QCPAbstractPlottable*> selectedPlottables = customPlot->selectedPlottables();
    foreach (QCPAbstractPlottable *plottable, selectedPlottables) {
        if (QCPCurve *curve = qobject_cast<QCPCurve*>(plottable)) {
            curve->setPen(QPen(Qt::red));
        } else if (QCPGraph *graph = qobject_cast<QCPGraph*>(plottable)) {
            graph->setPen(QPen(Qt::red));
        }
    }

    customPlot->replot(); // 重新绘制图形以显示更改
}
